<h1>Встроенные функции Python.</h1>

<p>Это функции, которые не требуют импорта и идут из коробки.</p>

<p>Рассмотрим некоторые из них.</p>

<h3>map(function, iterable, ...)</h3>

<p>Применяет функцию, которая передается в качестве первого параметра, к каждому элементу
списка, переданного в качестве второго параметра.</p>

<p>Возвращает результат в виде списка.</p>

<h3>Например.</h3>

<pre><code>items = [1, 2, 3]
print items

def mf(x):
    return x**2

result = map(mf,items)
print result
</code></pre>

<h3>Использование лямбда функции.</h3>

<p><strong>лямбда функция</strong> - это функция без названия (анонимная).</p>

<h3>Формат определения</h3>

<pre><code>lambda &lt;переменная, передаваемая параметром ф-ции&gt; : &lt;операция, возвращаемая функцией&gt;
</code></pre>

<p>Применяется для более короткой записи для улучшения читабельности кода т.к. при такой конструкции
нет необходимости определять функцию под каким то именем потому что она используется только в одном месте.</p>

<p>Но это не значит что мы не можем присвоить лямбда функцию переменной.</p>

<pre><code>items = [1, 2, 3]
lm = lambda x: x**2
l = map(lm, items)
print l

l = map(lambda x: x**2, items)
print l
</code></pre>

<h3>Вывод</h3>

<pre><code>[1, 2, 3]
[1, 4, 9]


words = ['It', 'is', 'raining', 'cats', 'and', 'dogs'] 
lengths = map(lambda word: len(word), words)

&gt;&gt; [2, 2, 7, 4, 3, 4]
</code></pre>

<h3>filter(function, iterable)</h3>

<p>Похоже на предыдущую тем, что тоже принимает два аргумента и применяет функцию
к каждому элементу переданного списка, но filter формирует и возвращает список 
из тех элементов списка для которых функция возвращает True.</p>

<p>Для этого каждый элемент списка будет передан в функцию-обработчик в качестве параметра.</p>

<pre><code>lst = [1,2,3,4,5,6,7,8,9]
def myf(x):
    if x%2 == 0:
        return True
    else:
        return False

res = filter(myf,lst)
print res

&gt;&gt; [2, 4, 6, 8]
</code></pre>

<h3>enumerate(sequence, start=0)</h3>

<p>Применяется для коллекций (строки, списки, словари и или любым другим объектом, поддерживающим итерацию и</p>

<p>создает объект, который генерирует кортежи, состоящие из двух элементов - индекса элемента и самого элемента.</p>

<pre><code>&gt;&gt;&gt; a = [10, 20, 30, 40]
&gt;&gt;&gt; for i in enumerate(a):
...     print(i)
... 
(0, 10)
(1, 20)
(2, 30)
(3, 40)
</code></pre>

<p>Пример аналога работы без применения enumerate:</p>

<pre><code>lst = ['one','two','three']

for i in range(len(lst)):
    print '%s-%s' % (i,lst[i])


for i,x in enumerate(lst):
    print '%s-%s' % (i,x)
</code></pre>

<p>В случае словарей нумеруются ключи:</p>

<pre><code>&gt;&gt;&gt; c = {1: 'a', 2: 'b', 3: 'c'}
&gt;&gt;&gt; for i in enumerate(c):
...     print(i)
... 
(0, 1)
(1, 2)
(2, 3)
</code></pre>

<p>Функция enumerate() используется для упрощения прохода по коллекциям в цикле, 
когда кроме самих элементов требуется их индекс.</p>

<h3>Функция list([iterable])</h3>

<p>Создает список из того, что ей передано.</p>

<p>Если передан словарь то создается список из его ключей.</p>

<pre><code>print list() &gt;&gt; []
print list('abc') &gt;&gt; ['a','b','c']
print list((5,6,7)) &gt;&gt; [5,6,7]
print list({'1':'hi', '2': 'bye'}) &gt;&gt; ['1', '2']
</code></pre>

<h3>Функция dict()</h3>

<p>С помощью этой функции мы можем создать словарь из переданного значения
в качестве которого передается список кортежей, которые будут преобразованы
в ключ и значение словаря.</p>

<pre><code>pairs = [("cat", "meow"), ("dog", "bark"), ("bird", "chirp")]

# Преобразование
lookup = dict(pairs)
</code></pre>

<h3>Output</h3>

<pre><code>{'bird': 'chirp', 'dog': 'bark', 'cat': 'meow'}
</code></pre>

<h3>Функция tuple([iterable])</h3>

<p>Возвращает кортеж с элементами в таком же порядке, каким он был в переданном списке.</p>

<pre><code>tuple([1, 2, 3]) returns (1, 2, 3)
</code></pre>
